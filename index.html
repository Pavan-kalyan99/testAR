<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Markerless WebAR Game with Drag</title>
<style>
html,body{margin:0;padding:0;height:100%;overflow:hidden;font-family:Arial,sans-serif;}
#overlay{
  position:fixed;top:0;left:0;width:100%;height:100%;
  background:#000; display:flex; align-items:center; justify-content:center;
  color:#fff; font-size:1.2em; z-index:20;
}
#ui{
  position:absolute; top:10px; left:10px; color:#fff; z-index:10; display:none;
}
#score{ background:rgba(0,0,0,0.5); padding:8px 12px; border-radius:8px; margin-bottom:8px;}
#message{ background:rgba(0,0,0,0.6); padding:8px 12px; border-radius:8px; max-width:80vw;}
</style>
</head>
<body>
<div id="overlay">Loading AR‚Ä¶</div>
<div id="ui">
  <div id="score">Score: 0</div>
  <div id="message"></div>
</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
import { GLTFLoader } from 'https://unpkg.com/three@0.152.2/examples/jsm/loaders/GLTFLoader.js';
import { ARButton } from 'https://unpkg.com/three@0.152.2/examples/jsm/webxr/ARButton.js';

let camera, scene, renderer, reticle, controller;
let collectibles=[], score=0, gameStarted=false;
const MAX_COLLECT=5, raycaster=new THREE.Raycaster();
let selectedObject=null, dragOffset=new THREE.Vector3();

const overlay=document.getElementById('overlay');
const ui=document.getElementById('ui');
const scoreEl=document.getElementById('score');
const messageEl=document.getElementById('message');

function showMessage(text,timeout=2400){
  messageEl.textContent=text;
  if(timeout>0) setTimeout(()=>{ if(messageEl.textContent===text) messageEl.textContent='';},timeout);
}

if(!('xr' in navigator)){
  overlay.textContent="‚ùå WebXR AR not supported on this device/browser.";
}else{
  init();
}

function init(){
  scene=new THREE.Scene();
  camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,0.01,20);
  renderer=new THREE.WebGLRenderer({antialias:true, alpha:true});
  renderer.setSize(window.innerWidth,window.innerHeight);
  renderer.xr.enabled=true;
  document.body.appendChild(renderer.domElement);

  const arButton=ARButton.createButton(renderer,{requiredFeatures:['hit-test']});
  document.body.appendChild(arButton);

  arButton.addEventListener('click',()=>{
    navigator.xr.requestSession('immersive-ar',{requiredFeatures:['hit-test']})
      .catch(()=>{ overlay.textContent="‚ö†Ô∏è Failed to start AR session."; });
  },{once:true});

  const light=new THREE.HemisphereLight(0xffffff,0xbbbbff,1);
  scene.add(light);

  // Reticle
  const ringGeo=new THREE.RingGeometry(0.07,0.09,32).rotateX(-Math.PI/2);
  reticle=new THREE.Mesh(ringGeo,new THREE.MeshBasicMaterial({color:0x00ff99}));
  reticle.matrixAutoUpdate=false; reticle.visible=false;
  scene.add(reticle);

  // Controller
  controller=renderer.xr.getController(0);
  controller.addEventListener('select', onSelect);
  controller.addEventListener('selectstart', onDragStart);
  controller.addEventListener('selectend', onDragEnd);
  scene.add(controller);

  window.addEventListener('resize', onWindowResize);

  overlay.style.display='none';
  ui.style.display='block';

  renderer.setAnimationLoop(render);
}

// Load GLTF collectible model
async function loadCollectibleModel(){
  const loader=new GLTFLoader();
  const gltf=await loader.loadAsync('models/collectible.glb');
  return gltf.scene;
}

// Spawn collectibles around reticle
async function spawnCollectibles(matrix){
  const origin=new THREE.Vector3(), quat=new THREE.Quaternion(), scale=new THREE.Vector3();
  matrix.decompose(origin,quat,scale);

  const offsets=[[0.7,0,-0.5],[-1.0,0,-0.8],[0.4,0,0.9],[-0.6,0,1.2],[1.2,0,0.3]];
  for(let i=0;i<MAX_COLLECT;i++){
    const pos=new THREE.Vector3(...offsets[i]).applyQuaternion(quat).add(origin);
    const model=await loadCollectibleModel();
    model.scale.set(0.1,0.1,0.1);
    model.position.copy(pos);
    scene.add(model);
    collectibles.push(model);
  }
}

// Tap to start game or collect
async function onSelect(){
  if(!reticle.visible){ showMessage("Point at a surface and tap."); return; }

  if(!gameStarted){
    gameStarted=true;
    await spawnCollectibles(reticle.matrix);
    showMessage(`Game started ‚Äî collect ${MAX_COLLECT} items!`);
    return;
  }

  // Raycast to collectibles
  const tempMatrix=new THREE.Matrix4(); tempMatrix.identity().extractRotation(controller.matrixWorld);
  raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
  raycaster.ray.direction.set(0,0,-1).applyMatrix4(tempMatrix);

  const intersects=raycaster.intersectObjects(collectibles,true);
  if(intersects.length>0){
    let picked=intersects[0].object;
    while(picked && !collectibles.includes(picked)) picked=picked.parent;
    if(picked) collect(picked);
  } else showMessage("No item at tap point.");
}

// Collect object
function collect(mesh){
  if(!collectibles.includes(mesh)) return;
  collectibles=collectibles.filter(m=>m!==mesh);
  scene.remove(mesh);
  score++; scoreEl.textContent=`Score: ${score}`;
  showMessage(`Collected ${score}/${MAX_COLLECT}`);
  if(score>=MAX_COLLECT) showMessage("You win! üéâ",6000);
}

// Drag-to-move interactions
function onDragStart(){
  if(!gameStarted) return;
  const tempMatrix=new THREE.Matrix4();
  tempMatrix.identity().extractRotation(controller.matrixWorld);
  raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
  raycaster.ray.direction.set(0,0,-1).applyMatrix4(tempMatrix);

  const intersects=raycaster.intersectObjects(collectibles,true);
  if(intersects.length>0){
    let picked=intersects[0].object;
    while(picked && !collectibles.includes(picked)) picked=picked.parent;
    if(picked){
      selectedObject=picked;
      dragOffset.copy(intersects[0].point).sub(selectedObject.position);
    }
  }
}

function onDragEnd(){ selectedObject=null; }

// WebXR hit-test
let hitTestSource=null, hitTestSourceRequested=false;

function render(timestamp,frame){
  if(frame){
    const session=renderer.xr.getSession();
    const refSpace=renderer.xr.getReferenceSpace();

    if(!hitTestSourceRequested){
      session.requestReferenceSpace('viewer').then(vRef=>{
        session.requestHitTestSource({space:vRef}).then(src=>hitTestSource=src);
      });
      session.addEventListener('end',()=>{hitTestSourceRequested=false; hitTestSource=null;});
      hitTestSourceRequested=true;
    }

    if(hitTestSource){
      const hits=frame.getHitTestResults(hitTestSource);
      if(hits.length>0){
        const pose=hits[0].getPose(refSpace);
        reticle.visible=true;
        reticle.matrix.fromArray(pose.transform.matrix);

        // Update dragged object along plane
        if(selectedObject){
          const planePos=new THREE.Vector3().setFromMatrixPosition(reticle.matrix);
          selectedObject.position.x=planePos.x - dragOffset.x;
          selectedObject.position.z=planePos.z - dragOffset.z;
        }
      } else reticle.visible=false;
    }
  }
  renderer.render(scene,camera);
}

function onWindowResize(){
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
}
</script>
</body>
</html>
